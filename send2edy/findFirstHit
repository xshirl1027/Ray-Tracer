void findFirstHit(struct ray3D *ray, double *lambda, struct object3D *Os, struct object3D **obj, struct point3D *p, struct point3D *n, double *a, double *b)
{
 // Find the closest intersection between the ray and any objects in the scene.
 // It returns:
 //   - The lambda at the intersection (or < 0 if no intersection)
 //   - The pointer to the object at the intersection (so we can evaluate the colour in the shading function)
 //   - The location of the intersection point (in p)
 //   - The normal at the intersection point (in n)
 //
 // Os is the 'source' object for the ray we are processing, can be NULL, and is used to ensure we don't 
 // return a self-intersection due to numerical errors for recursive raytrace calls.
 //

  double min_dist = 99999;
  double curr_len = 0;

  struct object3D *curr_obj;
  curr_obj = object_list;
  
  	//while(curr_obj != NULL){ //comment out loop, just get just plane to render
	    curr_obj->intersect(curr_obj, ray, lambda, p, n, a, b);
	    if(*lambda>0){
	    	//struct point3D *dist_v = (struct point3D*)malloc(sizeof(struct point3D));
	    	//memcpy(dist_v, p, sizeof(struct point3D));
	    	//subVectors(&(ray->p0), dist_v);
	    	curr_len = *lambda; //length(dist_v);
	    	if ((min_dist > curr_len) && (curr_len > 0)){
	      	min_dist = curr_len;
	      	*obj = curr_obj;
	    }
	 }

}
