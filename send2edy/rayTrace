 
void rayTrace(struct ray3D *ray, int depth, struct colourRGB *col, struct object3D *Os)
{
 // Ray-Tracing function. It finds the closest intersection between
 // the ray and any scene objects, calls the shading function to
 // determine the colour at this intersection, and returns the
 // colour.
 //
 // Os is needed for recursive calls to ensure that findFirstHit will
 // not simply return a self-intersection due to numerical
 // errors. For the top level call, Os should be NULL. And thereafter
 // it will correspond to the object from which the recursive
 // ray originates.
 //

	 double lambda;		// Lambda at intersection
	 double a,b;		// Texture coordinates
	 struct object3D *obj;	// Pointer to object at intersection
	 struct point3D p, tp;	// Intersection point
	 struct point3D n, tn;	// Normal at intersection
	 struct colourRGB I;	// Colour returned by shading function

	 if (depth>MAX_DEPTH)	// Max recursion depth reached. Return invalid colour.
	 {
	  col->R=-1;
	  col->G=-1;
	  col->B=-1;
	  return;
	 } 
	 else
	 {
		findFirstHit(ray, &lambda, Os, &obj, &p, &n, &a, &b);

		//if (obj != NULL){
		if (lambda > 0){ //intersection == true, color it
			col->R = obj->col.R;
			col->G = obj->col.G;
			col->B = obj->col.B;
		}
		else //darkness
		{
			col->R =0.0;
			col->G =0.0;
			col->B =0.0;
		}
		// struct ray3D lightray;
		// struct point3D *dir = (struct point3D*)malloc(sizeof(struct point3D));
		// if(lambda > 0)
		// {	

		// 	struct pointLS *curr_light = light_list;
		// 	while (curr_light!=NULL)
		// 	{
		// 		memcpy(dir, &curr_light->p0, sizeof(struct point3D));
		// 		subVectors(&p, dir);
		// 		lightray = *(newRay(&p, dir));
		// 		normalize(&(lightray.d));
		// 		findFirstHit(&lightray, &lambda, Os, &obj, &p, &n, &a, &b);
		// 		//printf("%f", lambda);
		// 		if(lambda <= 0){
		// 			//printf("intersected!!!");
		// 			rtShade(obj, &p, &n, ray, depth, a, b, &I);
					
		// 			col->R += I.R;
		// 			col->G += I.G;
		// 			col->B += I.B;
		// 			printf("RGB %f, %f, %f\n", col->R, col->G, col->B);
					
		// 		}
		// 		curr_light = curr_light->next;
		// 	}

			//if(depth>0){
				//create reflected ray
				//rayTrace(struct ray3D *ray, int depth, struct colourRGB *col, struct object3D *Os)

			//}
		// }
		
	 }
